<!DOCTYPE html><html lang="english"><head>  <title>exported project</title>  <meta name="viewport" content="width=device-width, initial-scale=1.0" />  <meta charset="utf-8" />  <meta property="twitter:card" content="summary_large_image" />  <style>    html {      line-height: 1.15;    }    body {      margin: 0;    }    * {      box-sizing: border-box;      border-width: 0;      border-style: solid;    }    p,    li,    ul,    pre,    div,    h1,    h2,    h3,    h4,    h5,    h6 {      margin: 0;      padding: 0;    }    button,    input,    optgroup,    select,    textarea {      font-family: inherit;      font-size: 100%;      line-height: 1.15;      margin: 0;    }    button,    select {      text-transform: none;    }    button,    [type="button"],    [type="reset"],    [type="submit"] {      -webkit-appearance: button;    }    button::-moz-focus-inner,    [type="button"]::-moz-focus-inner,    [type="reset"]::-moz-focus-inner,    [type="submit"]::-moz-focus-inner {      border-style: none;      padding: 0;    }    button:-moz-focus,    [type="button"]:-moz-focus,    [type="reset"]:-moz-focus,    [type="submit"]:-moz-focus {      outline: 1px dotted ButtonText;    }    a {      color: inherit;      text-decoration: inherit;    }    input {      padding: 2px 4px;    }    img {      display: block;    }  </style>  <style>    html {      font-family: Inter;      font-size: 16px;    }    body {      font-weight: 400;      font-style: normal;      text-decoration: none;      text-transform: none;      letter-spacing: normal;      line-height: 1.15;      color: var(--dl-color-gray-black);      background-color: var(--dl-color-gray-white);    }  </style>  <link rel="stylesheet"    href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" />  <link rel="stylesheet"    href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" />  <link rel="stylesheet" href="./style.css" /></head><body>  <div>    <link href="./desktop2333.css" rel="stylesheet" />    <div class="desktop2333-frame346">      <img src="public/playground_assets/rectangle1334-waw-200h.png" alt="Rectangle1334" class="desktop2333-image" />      <span class="desktop2333-text">AI ALIGNMENT FORUM</span>      <div align="right">        <img src="public/playground_assets/rectangle2337-s69l-200h.png" alt="Rectangle2337"          class="desktop2333-image1" />        <img src="public/playground_assets/rectangle4338-9v7c-200h.png" alt="Rectangle4338"          class="desktop2333-image2" />        <img src="public/playground_assets/rectangle3339-1qe3-200h.png" alt="Rectangle3339"          class="desktop2333-image3" />        <img alt="Ellipse1340" src="public/playground_assets/ellipse1340-0si.svg" class="desktop2333-svg" />        <img alt="Line1341" src="public/playground_assets/line1341-6zp.svg" class="desktop2333-svg1" />        <img alt="Star1342" src="public/playground_assets/star1342-4ija.svg" class="desktop2333-svg2" />        <img alt="Vector1343" src="public/playground_assets/vector1343-n2es.svg" class="desktop2333-svg3" />        <span class="desktop2333-text02">Stampy Stomper        </span>      </div>    </div>    <div class="desktop2333-frame142">      <span class="desktop2333-text04">        A non-trivial solution to the protein folding problem      </span>      <span class="desktop2333-text06">        <span class="desktop2333-text07">by</span>        <span class="desktop2333-text08">paulf christian</span>      </span>      <span class="desktop2333-text09">        <span class="desktop2333-text10">24 min read</span>      </span>      <span class="desktop2333-text11">        <span class="desktop2333-text12">2nd Mar 2022</span>      </span>      <span class="desktop2333-text13">        <span class="desktop2333-text14">0 comment</span>      </span>      <img src="public/playground_assets/rectangle5350-xr8e-200h.png" alt="Rectangle5350" class="desktop2333-image4" />      <span class="desktop2333-text15">        <span class="desktop2333-text16">Neuromorphic AI</span>      </span>      <span class="desktop2333-text17">        <span class="desktop2333-text18">+ Add Tag</span>      </span>      <img alt="Ellipse2353" src="public/playground_assets/ellipse2353-lolb.svg" class="desktop2333-svg4" />      <img alt="Ellipse3354" src="public/playground_assets/ellipse3354-fqh.svg" class="desktop2333-svg5" />      <img alt="Ellipse4355" src="public/playground_assets/ellipse4355-4nrr.svg" class="desktop2333-svg6" />      <img alt="Vector2356" src="public/playground_assets/vector2356-jp79.svg" class="desktop2333-svg7" />      <span class="desktop2333-text19">        <span class="desktop2333-text20">7</span>      </span>    </div>    <div class="desktop2333-frame243">      <span class="desktop2333-text21">        <p>Consider the problem of finding the structure of a protein: that is, the set of amino acids that make up a protein chain. Given the sequence of amino acids, the goal is to find a low-energy (low-entropy) structure. An efficient computer can find a low-entropy (folded) design in a few minutes, whereas any traditional search algorithm would run for at least tens of thousands of computational years. If we knew a mathematical argument for why "most" protein structures will fold in a particular way, then we would have a highly useful insight into biology. In practice, there are many possible configurations, and so we must actually build a huge amount of empirical evidence. (See my blog post for more details.)</p><br><p>Why is this a remarkable fact? In a certain sense, the answer is quite simple: proteins are not really rigid (for example, in the middle of a folding process, they "walk around" as they assemble). In other words, it is not the case that some set of amino acids will <em>always</em> fold in a particular structure, they are <em>more or less</em> likely to fold in this particular structure <em>if things are otherwise random enough</em>. In this sense, protein folding is a "small" optimization problem.</p><br><p>Unfortunately, this argument is very indirect, and moreover we do not presently know good methods for determining the probability of a particular structure. In this post, I apply a technique (described in A new technique for proving theorems about large finite factored sets) which gives a clean explanation for why "most proteins folded according to the'standard way' will fold" in a particular way. In short, this is a new proof of a fact that is extremely important scientifically and mathematically, and moreover our method gives a significantly shorter proof in principle.</p><br><p>The post grew out of an idea with Wei Dai and Alex Appel, and grew out of discussion and collaborations with Nick Tarleton. This post is a synthesis that I'm mostly responsible for; I was originally motivated by a post on the protein folding problem with Wei Dai, but the main thrust of the proof is new. I strongly encourage reading Tarleton et al on the protein folding proof before reading this post, which builds on ideas in the first three papers on the technique; in addition there is substantial overlap with the ideas outlined in Tarleton et al's recent paper "Incompleteness and undecidability of proof search".</p><br><p>The post draws heavily from a few key books, the main ones being <em>Probabilistic Inference and the Search for Knowledge</em> by Leslie Valiant and <em>A Computational Perspective on Scientific Reasoning</em> by Paul Christiano. I have read this material extensively but am unaware of any good concise writeups of the relevant ideas, which is unfortunate. It is quite possible that both of these works are a great read to understand this post.</p><br><p>The problem</p><br><p>We first consider an abstract simplification of the protein folding problem: a protein chain of length M will fold in many possible structures, with structure given by M-1 sequences of amino acids; here we give each sequence as a single symbol. In this abstract formalism it seems reasonable to consider all sequences of the same length to have the same energy; and it seems plausible to assume some other information (for example, we do not allow any information about the relative positions of the amino acids in the chain).</p><br><p>Now suppose that the chain length M is huge. Let N be the number of sequences of length M, each of which can fold in various possible ways (note this is very different from the number P of paths through a graph—for each path a sequence needs to fold). So N≈P/M (I am assuming that each sequence can fold in several ways). As N is growing exponentially in M, we cannot even write out N in terms of letters; instead, we consider all sequences of length M to be "independent events" which might or might not occur. Thus we can't compare the probability of two independent events (because there is no guarantee that a particular sequence never appears in both events), and comparing individual events requires a different mathematical treatment. So how can we compute probabilities for this sort of thing?</p><br><p>Now suppose we run a search over M-1 sequences with some energy-minimizing metric. At some point, we end up in a particular sequence (call it sequence i), and we have two options.</p><br><p>First, we could check if the sequence i is a good folded protein, and if so we output it as our solution.</p><br><p>Or, we could find a set of sequences i1,i2,...,in with n≈PN/3 such that for each sequence we can show that its energy is ≤ the energy of sequence i, and moreover this property holds for the combination of all n sequences (i.e. for every sequence in the set, we can prove that its energy is &lt;= that of sequence i).</p><br><p>If such a property holds, clearly the number of such solutions can be approximated in time polynomial with respect to N (since searching over n sequences of length M requires time polynomial).</p><br><p>This is not enough! We haven't shown anything about the behavior of n or i, i.e. n andi are not yet fixed. We don't know whether the set of sequences is actually non-empty, we don't know what the solution i is, and we don't know whether i is indeed very likely to be high in the energy ranking, or whether it's very similar to high in the ranking but not actually high.</p><br><p>These problems are present if we have solved the protein folding problem via computer search, which should in theory be tractable. In practice, these are very complicated problems, and even with current methods it is difficult to solve the problem. Note that the difficulty is not that the set of solutions is "too big" (although this is part of the problem); the difficulty is that it is difficult to show for "reasonable" solutions whether they are actually good.</p><br><p>We must show that any "reasonable", though unknown, solution is not going to be too bad. Therefore the problem should be solvable by computer search, but the set of solutions that are possible under current methods must be non-vacuous, and the analysis must show that this non-vacuity arises at a particular point in the search tree which is too high up to be interesting.</p>      </span>    </div>  </div></body></html>