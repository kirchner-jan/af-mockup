<!DOCTYPE html><html lang="english"><head>  <title>exported project</title>  <meta name="viewport" content="width=device-width, initial-scale=1.0" />  <meta charset="utf-8" />  <meta property="twitter:card" content="summary_large_image" />  <style>    html {      line-height: 1.15;    }    body {      margin: 0;    }    * {      box-sizing: border-box;      border-width: 0;      border-style: solid;    }    p,    li,    ul,    pre,    div,    h1,    h2,    h3,    h4,    h5,    h6 {      margin: 0;      padding: 0;    }    button,    input,    optgroup,    select,    textarea {      font-family: inherit;      font-size: 100%;      line-height: 1.15;      margin: 0;    }    button,    select {      text-transform: none;    }    button,    [type="button"],    [type="reset"],    [type="submit"] {      -webkit-appearance: button;    }    button::-moz-focus-inner,    [type="button"]::-moz-focus-inner,    [type="reset"]::-moz-focus-inner,    [type="submit"]::-moz-focus-inner {      border-style: none;      padding: 0;    }    button:-moz-focus,    [type="button"]:-moz-focus,    [type="reset"]:-moz-focus,    [type="submit"]:-moz-focus {      outline: 1px dotted ButtonText;    }    a {      color: inherit;      text-decoration: inherit;    }    input {      padding: 2px 4px;    }    img {      display: block;    }  </style>  <style>    html {      font-family: Inter;      font-size: 16px;    }    body {      font-weight: 400;      font-style: normal;      text-decoration: none;      text-transform: none;      letter-spacing: normal;      line-height: 1.15;      color: var(--dl-color-gray-black);      background-color: var(--dl-color-gray-white);    }  </style>  <link rel="stylesheet"    href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" />  <link rel="stylesheet"    href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" />  <link rel="stylesheet" href="./style.css" /></head><body>  <div>    <link href="./desktop2333.css" rel="stylesheet" />    <div class="desktop2333-frame346">      <img src="public/playground_assets/rectangle1334-waw-200h.png" alt="Rectangle1334" class="desktop2333-image" />      <span class="desktop2333-text">AI ALIGNMENT FORUM</span>      <div align="right">        <img src="public/playground_assets/rectangle2337-s69l-200h.png" alt="Rectangle2337"          class="desktop2333-image1" />        <img src="public/playground_assets/rectangle4338-9v7c-200h.png" alt="Rectangle4338"          class="desktop2333-image2" />        <img src="public/playground_assets/rectangle3339-1qe3-200h.png" alt="Rectangle3339"          class="desktop2333-image3" />        <img alt="Ellipse1340" src="public/playground_assets/ellipse1340-0si.svg" class="desktop2333-svg" />        <img alt="Line1341" src="public/playground_assets/line1341-6zp.svg" class="desktop2333-svg1" />        <img alt="Star1342" src="public/playground_assets/star1342-4ija.svg" class="desktop2333-svg2" />        <img alt="Vector1343" src="public/playground_assets/vector1343-n2es.svg" class="desktop2333-svg3" />        <span class="desktop2333-text02">Stampy Stomper        </span>      </div>    </div>    <div class="desktop2333-frame142">      <span class="desktop2333-text04">        A tale of Two Languages      </span>      <span class="desktop2333-text06">        <span class="desktop2333-text07">by</span>        <span class="desktop2333-text08">Flo_Underflo</span>      </span>      <span class="desktop2333-text09">        <span class="desktop2333-text10">24 min read</span>      </span>      <span class="desktop2333-text11">        <span class="desktop2333-text12">2nd Mar 2022</span>      </span>      <span class="desktop2333-text13">        <span class="desktop2333-text14">0 comment</span>      </span>      <img src="public/playground_assets/rectangle5350-xr8e-200h.png" alt="Rectangle5350" class="desktop2333-image4" />      <span class="desktop2333-text15">        <span class="desktop2333-text16">Neuromorphic AI</span>      </span>      <span class="desktop2333-text17">        <span class="desktop2333-text18">+ Add Tag</span>      </span>      <img alt="Ellipse2353" src="public/playground_assets/ellipse2353-lolb.svg" class="desktop2333-svg4" />      <img alt="Ellipse3354" src="public/playground_assets/ellipse3354-fqh.svg" class="desktop2333-svg5" />      <img alt="Ellipse4355" src="public/playground_assets/ellipse4355-4nrr.svg" class="desktop2333-svg6" />      <img alt="Vector2356" src="public/playground_assets/vector2356-jp79.svg" class="desktop2333-svg7" />      <span class="desktop2333-text19">        <span class="desktop2333-text20">7</span>      </span>    </div>    <div class="desktop2333-frame243">      <span class="desktop2333-text21">        <p>What I am about to say below is a true story of a computer I wrote on, in two languages:</p><br><p>The computer itself was a P-1 mini. It was written in PL/1.</p><br><p>The front-end program was written in Assembler-Script, which, as I recall, was the first functional programming language of its sort. It was, at the time, almost a new language that is built around the syntax A::=... (define the variable A as the last argument) and the primitive functions:</p><br><p>A(B,C)      return (A(B),A(C))</p><br><p>B+C     A(B,C(B+C))</p><br><p>It did some stuff with recursions (with the help, that is, of a library for working with recurrences written in PL/3, so the front-end was not very portable to the various systems that it was written on), some kind of database and a bunch of other stuff.</p><br><p>And some time after I wrote the front-end, I wrote a server to listen for client requests, which were, as I recall it, written in PL/6/\xe2\x80\x8bCL.</p><br><p>If, while writing the server, I had wanted to write a test for the server, I could have used A::=... to define something inside the server as a variable and use A(*) to return that value after the server received a client request. This was because the PL/2 was part of the server's environment, so I could simply call it within the server.</p><br><p>But my purpose with the server was not to see an error message nor read a log file and I had also no interest in the server printing a response to the front-end. I wanted a simple connection to the database that was terminated once the connection was over. Also, the language used at that time, a variant of OCaml, made it straightforward to create abstractions.</p><br><p>So, I didn't want to use PL/2, it would be hard to get things working with PL/2 and, also, I did not have time to deal with the messiness that comes with PL/2, including a lot of stuff that you need to do if you want a functional programming language. What I wanted in fact was a language that is a superset of PL/2. And that's what I got:</p><br><p>B(C)   return (B(b,C),B(c))</p><br><p>B()  B(*)</p><br><p>That's it. You can't do stuff with it that requires recursiveness (in particular, you can't recursively define something that uses your language of recursions) and you also can't use the primitive, since it's no such a function.</p><br><p>But in any case, there is one thing that it has: it can use the functions contained in the environment. The function can be called with the address of the environment's code, or you can call a function using any arguments that the language supports and you get a result back immediately.</p><br><p>So after I had written the server on PL/\xe2\x80\x8b6 I wrote the front end on PL/1 and that server is using A(), not B(). Also A() gives an error or a log message if the database is down. I wanted to use the language for something other than the server and that's where Haskell comes in:</p><br><p>A()   return (f(),f())</p><br><blockquote>
<p>f,     h :: B a   if f h f otherwise</p>
</blockquote><br><blockquote>
<pre><code>if f(b,c)  then (return b) if b  h f else c when b &gt; return c else d
</code></pre>
</blockquote><br><blockquote>
<p>if f</p>
</blockquote><br><p>If you are willing to do the work and learn Haskell on your own, then, reading the documentation for A() you gain a lot, in particular, you learn that when the database that you have requested is down, then f() returns ().</p><br><p>If you know A() and f() you can also do some of stuff you can do in Haskell, namely:</p><br><ul>
<li>Writing an interface: interface f in Haskell is a function from a function and an argument. If you want to write a Haskell function that takes, not only a function, but also a parameter and a list of parameters, then you can implement it using f(). This enables functions that have side effects, but you need to understand how this differs from the functionality of functions defined with if statements that return boolean values.</li>
</ul><br><ul>
<li>Using the primitive in the environment: as shown above, I can define A() and the variable to be returned by A() inside the code of the server that the front end of my program is calling. The server then returns the variable or, if you wanted, the error message or whatever. Because the variable is declared inside of the code that calls the server, it is visible to the front end, but its value will only be available inside the server after the whole, if not terminated, connection is over. This way, the code that calls A() can be used to write a program to make calls to A().</li>
</ul><br><p>And here, I have managed to write an application in two different languages, each of them with its own set of features (it seems like Haskell is a superset, but it is not exactly...):</p><br><p>PL/\xe2\x80\x8b1 has as a basis for its language a functional programming language, and the primitive function A(). It has nothing, no built-in primitives or other language extensions, and no recursiveness either (unless you go looking in its manual)... The database is accessible from the application in the server and not from the front end, so testing the server is also made easier and the server is less bulky because it has no access to the database.</p><br><p>The PL/6 that my client is using has the same as the PL/1 with a few less features, like only allowing recursives from within the code under the application (you can't define something inside your server like </p><br><p>B()=B(B(*),c).</p><br><p>and it also has no built-in function, but, like in C, you can define a new one.</p><br><p>The Haskell program that connects to the database is also different from the front end: rather than being a C application, it is an application in any other language (as it is in no other language than Haskell). It is more powerful because it can return immediately whatever it would return if it got a connection and actually did a query to the database and it is just as portable to other operating systems and it runs on any machine that supports Haskell.</p><br><p><strong>I can go on.</strong></p><br><p>But yes, this was not the last time and not the only time that I wrote my application in two languages in the course of a month or two.</p><br><p>So do you have any clue as to how I did? I can guess, yes, and it's basically that I used the same language for the application and the server. For the application itself this is the C of Haskell, and for the server, well, as I guess it was the C++ of Haskell (and for the interface with the database I decided to use the PL/2 with extra functions written in the PL, of course).</p><br><p>What I was doing was using a language for two different things at the same time, while keeping to the same language for each. The more I do this, the harder it gets to remember two languages, for each they differ in one or two aspects but not by much (for example, OCaml allows recursive definitions and has a built-in database, so it is not as good as Haskell).</p><br><p>I am planning that in a month or two, I shall write a compiler that compiles Haskell code to both a normal application and a server application.</p><br><p><strong>Do you think that this is a good idea?</strong></p><br><p>And of course, if I am wrong, please point out where and why.</p>      </span>    </div>  </div></body></html>