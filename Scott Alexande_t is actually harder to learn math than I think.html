<!DOCTYPE html><html lang="english"><head>  <title>exported project</title>  <meta name="viewport" content="width=device-width, initial-scale=1.0" />  <meta charset="utf-8" />  <meta property="twitter:card" content="summary_large_image" />  <style>    html {      line-height: 1.15;    }    body {      margin: 0;    }    * {      box-sizing: border-box;      border-width: 0;      border-style: solid;    }    p,    li,    ul,    pre,    div,    h1,    h2,    h3,    h4,    h5,    h6 {      margin: 0;      padding: 0;    }    button,    input,    optgroup,    select,    textarea {      font-family: inherit;      font-size: 100%;      line-height: 1.15;      margin: 0;    }    button,    select {      text-transform: none;    }    button,    [type="button"],    [type="reset"],    [type="submit"] {      -webkit-appearance: button;    }    button::-moz-focus-inner,    [type="button"]::-moz-focus-inner,    [type="reset"]::-moz-focus-inner,    [type="submit"]::-moz-focus-inner {      border-style: none;      padding: 0;    }    button:-moz-focus,    [type="button"]:-moz-focus,    [type="reset"]:-moz-focus,    [type="submit"]:-moz-focus {      outline: 1px dotted ButtonText;    }    a {      color: inherit;      text-decoration: inherit;    }    input {      padding: 2px 4px;    }    img {      display: block;    }  </style>  <style>    html {      font-family: Inter;      font-size: 16px;    }    body {      font-weight: 400;      font-style: normal;      text-decoration: none;      text-transform: none;      letter-spacing: normal;      line-height: 1.15;      color: var(--dl-color-gray-black);      background-color: var(--dl-color-gray-white);    }  </style>  <link rel="stylesheet"    href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" />  <link rel="stylesheet"    href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" />  <link rel="stylesheet" href="./style.css" /></head><body>  <div>    <link href="./desktop2333.css" rel="stylesheet" />    <div class="desktop2333-frame346">      <img src="public/playground_assets/rectangle1334-waw-200h.png" alt="Rectangle1334" class="desktop2333-image" />      <span class="desktop2333-text">AI ALIGNMENT FORUM</span>      <div align="right">        <img src="public/playground_assets/rectangle2337-s69l-200h.png" alt="Rectangle2337"          class="desktop2333-image1" />        <img src="public/playground_assets/rectangle4338-9v7c-200h.png" alt="Rectangle4338"          class="desktop2333-image2" />        <img src="public/playground_assets/rectangle3339-1qe3-200h.png" alt="Rectangle3339"          class="desktop2333-image3" />        <img alt="Ellipse1340" src="public/playground_assets/ellipse1340-0si.svg" class="desktop2333-svg" />        <img alt="Line1341" src="public/playground_assets/line1341-6zp.svg" class="desktop2333-svg1" />        <img alt="Star1342" src="public/playground_assets/star1342-4ija.svg" class="desktop2333-svg2" />        <img alt="Vector1343" src="public/playground_assets/vector1343-n2es.svg" class="desktop2333-svg3" />        <span class="desktop2333-text02">Stampy Stomper        </span>      </div>    </div>    <div class="desktop2333-frame142">      <span class="desktop2333-text04">        t is actually harder to learn math than I think      </span>      <span class="desktop2333-text06">        <span class="desktop2333-text07">by</span>        <span class="desktop2333-text08">Scott Alexande</span>      </span>      <span class="desktop2333-text09">        <span class="desktop2333-text10">24 min read</span>      </span>      <span class="desktop2333-text11">        <span class="desktop2333-text12">2nd Mar 2022</span>      </span>      <span class="desktop2333-text13">        <span class="desktop2333-text14">0 comment</span>      </span>      <img src="public/playground_assets/rectangle5350-xr8e-200h.png" alt="Rectangle5350" class="desktop2333-image4" />      <span class="desktop2333-text15">        <span class="desktop2333-text16">Neuromorphic AI</span>      </span>      <span class="desktop2333-text17">        <span class="desktop2333-text18">+ Add Tag</span>      </span>      <img alt="Ellipse2353" src="public/playground_assets/ellipse2353-lolb.svg" class="desktop2333-svg4" />      <img alt="Ellipse3354" src="public/playground_assets/ellipse3354-fqh.svg" class="desktop2333-svg5" />      <img alt="Ellipse4355" src="public/playground_assets/ellipse4355-4nrr.svg" class="desktop2333-svg6" />      <img alt="Vector2356" src="public/playground_assets/vector2356-jp79.svg" class="desktop2333-svg7" />      <span class="desktop2333-text19">        <span class="desktop2333-text20">7</span>      </span>    </div>    <div class="desktop2333-frame243">      <span class="desktop2333-text21">        <p>(Warning: long, technical, and somewhat technical. If you don't like math, skim or skip the section on AI risk.)</p><br><p>The title is a reference to Eliezer's article on turing completeness, and more specifically "The Problem of the Church-Turing Thesis." There's an excellent summary of the article on an even-greater-blog, but I strongly recommend reading the summary first.</p><br><p>Church-Turing thesis is basically a statement about the relationship between computers and the universe, a theorem proving that the two are isomorphic. It's not the most commonly used theorem in math, it's really obscure, and has a reputation of being somewhat mysterious and counter-intuitive. It's also not generally used in math, so lots of people don't even know it exists, let alone that it's so important and cool. All of these characteristics, while not exactly attractive, can be explained using the second law of thermodynamics.</p><br><p>At the start, it's a simple proof by P. L. Halmos: there is no function that you can implement on your computer which takes in inputs, and outputs either 0 or 1. (The "halting problem" is when the function returns nothing, or returns 2 when it doesn't. We can make our inputs into programs, make my program output either 0 or 1 depending on whether the input is a valid program. Then we just run this program forever and wait.) For any set of rules governing the input of this function on the computer, there is always a rule that could be added which would make the computer return 0 on this input.</p><br><p>"Hang on," you say, "what if I know that the function always returns 2?" Even so, you can still ask "can I prove that the function always outputs 0?" No, without more knowledge, you can't prove anything.</p><br><p>What about, what if I know that there is a valid input on which the function always returns 0. Or maybe, you say, I know that there exists a function which returns 1 and never returns 0. Then what about all those functions that return 1 on every valid input? What if I add one of those to the program? Then I've got a new function, and now it's one that never returns 1 on my test cases! What if I add enough functions to the program? I've got an infinite set of functions, and I've got an oracle for infinite sets of functions (that takes in two infinite sets, finds an infinite set that's the intersection of the two, and outputs either "0" or "1\xe2\x80\xb2\xe2\x80\xb2), and I have an oracle for sets of functions that's never "wrong" about which functions have never returned 0 on which inputs, because the set of functions with that property is infinite!</p><br><p>So I see no way that you could prove that there is no function which takes in input, and outputs the same thing for the same reason every time.</p><br><p>It has a huge impact on what is and isn't a valid program (because the only way you'd ever get a function from an infinite set in the first place is by picking something from the infinite set), but it isn't a serious issue for practical programming. After that's established in the paper, the next step is figuring out why this means that "computers" can be isomorphous to "the universe," and that we should therefore be able to do a better job of predicting what happens when we run our programs on real computers. And of course, it has nothing but good implications for the study of AI.</p><br><p>Which brings us to the next step in the evolution of turing completeness: turing's incompleteness theorem.</p><br><p>Let's suppose we make it so that all the possible functions are enumerable. Then our computer has an infinite list of all possible inputs. There's only one list, but infinite lists are easy, so for the sake of clarity let's look at just one list.</p><br><p>The first item on our list is a symbol "0". We have to add an oracle corresponding to the set of all functions which return 0. Well, there's the empty set: {}. We don't want that, we want every function of our list. Our oracle can answer "do you know what every function looks like?" and "do you know every function exists?" "No, and no."</p><br><p>So we have {0} as our first oracle. What about {0,1}? It's an infinite subset of the set, but how would we rule out functions within it? "Ah, yes, we know of all functions in this subset except {0,1}. Good evening." Our final answer is: {0,1,{0},{0,1,}}, and if we query "do you know everything?" with that oracle we get "no."</p><br><p>But there's one more function to our list: it's the input that we put in our computer. How come we have an oracle which isn't allowed to test something that we're explicitly testing? We know that the input that our computer takes in is an infinite list of numbers, but the list isn't fixed, it's still open. But we know that the output will be in some particular location, so we could just check to see if the oracle returned 1 at that location! "Ah, yes. The oracle will say 'it's 0 unless it's at the start of the list.'"</p><br><p>So now our final oracle is: {0} + {0,1}, and if we ask it "do you know if our function works?" well, "no." Because our function only accepts its input, and its output, if it's inside our set of all possible outputs (or else the output is 0).</p><br><p>This means that for any possible turing complete set (in particular all computer programs and all set theory axioms), there's a way of extending it to include as many as you feel like. Let's suppose that the first turing complete set is a set of basic operations that every computer does, such as addition and multiplication. Let's further suppose that we have an oracular extension that includes every set of functions that satisfies whatever property we decided is a "turing complete" oracle.</p><br><p>The oracles are always allowed to return a "don't know" answer.</p><br><p>Now let's look at one more function.</p><br><p>0+1 is not an oracle. Its oracle doesn't know what we're talking about. It's also a "don't-know" function. It will return "don't know."</p><br><p>But it's a "don't need an oracle" function because given that {0} +{0,1}, we know the answer.</p><br><p>We can extend our list however we want, and our set will always have a solution, but no matter how much we extend it, that's always our final set. There's no turing complete set which extends our set of operations, or which contains the solution to any member of our set. There can't possibly be. No proof exists to the first turing incompleteness theorem, and there can't ever exist a turing complete set, because if the turing complete set contained a function that didn't output what it was supposed to, the oracle would know that.</p><br><p>So this is just a restatement of the turing incompletetion theorem more rigorously than it's ever had a chance of being before. But I still think that these three examples show what a turing completeness theorem is, to a level that lets you grok it without knowing much set theory.</p><br><p>Now on to the next stage: turing's own incompleteness theorem: no one can prove their own soundness.</p><br><p>Let R be a formal system, and Q be a sentence in R. Since turing, we're just as well-placed to formalize "prove Q" as to formalize "if this statement is provable, then I accept it." So if we can't prove it, it's unprovable, then can't prove it.</p><br><p>For example, in propositional logic, a statement can be said to be provable if every propositional argument for it is valid (that is, every possible chain of propositional implications leads to a conclusion that proves the statement).</p><br><p>But what if we take propositional logic and add the sentence:</p><br><p>"If A is a propositional implication, then A."</p><br><p>(where "A" can be any statement that we can express as a propositional implication)</p><br><p>Well, now it's clear from the tautologies that:</p><br><p>(A-&gt;B)\xe2\x86\x92(A-&gt;B).</p><br><p>But if we add the sentence A-&gt;B and A is in propositional logic (A and B are propositional implications), then now it's clear that:</p><br><p>A and B</p><br><p>So it's clear that A-&gt;A is an implication, and A-&gt;B-&gt;A isn't possible in this formal system. That's turing's incomputetion argument.</p><br><p>So if we ask a turing complete system for "prove A?", will it be able to answer "don't know"? No, because A is a special case of a bigger thing, the statement "if A is valid then don't know".</p><br><p>And if we ask it to prove "if not A, then B", it knows it's false, and so it knows "don't know".</p>      </span>    </div>  </div></body></html>